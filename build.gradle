//file:noinspection GroovyAssignabilityCheck
//file:noinspection GrUnresolvedAccess

import com.github.jk1.license.filter.ExcludeTransitiveDependenciesFilter
import com.github.jk1.license.filter.LicenseBundleNormalizer
import com.github.jk1.license.render.InventoryHtmlReportRenderer
import com.github.jk1.license.render.InventoryMarkdownReportRenderer
import org.siouan.frontendgradleplugin.infrastructure.gradle.RunNpm

import java.text.SimpleDateFormat

plugins {
  id 'java'
  id 'idea'

  id 'signing'
  id 'maven-publish'
  id "io.github.gradle-nexus.publish-plugin" version "1.1.0"
  id 'java-library'

  id 'edu.sc.seis.launch4j' version '2.5.3'
  id 'org.siouan.frontend-jdk8' version '6.0.0'
  id 'org.springframework.boot' version '2.7.3'
  id 'io.spring.dependency-management' version '1.0.13.RELEASE'

  id 'com.github.jk1.dependency-license-report' version '2.0'
}

repositories {
  mavenCentral()
  maven { url "https://jitpack.io" }
  maven { url 'https://repo.spring.io/release' }
}

sourceSets {
  main {
    java {
      srcDirs = ['backend/main/java']
    }
    resources {
      srcDirs = ['backend/main/resources']
    }
  }
  test {
    java {
      srcDirs = ['backend/test/java']
    }
    resources {
      srcDirs = ['backend/test/resources']
    }
  }
}

sourceCompatibility = targetCompatibility = JavaVersion.VERSION_1_8

configurations {
  all {
    // Exclude logging from dependencies because we already have logging set up
    exclude group: 'org.springframework.boot', module: 'spring-boot-starter-logging'
    exclude group: 'org.slf4j', module: 'slf4j-log4j12'
  }
}

dependencies {
  // Backend
  implementation 'de.griefed:versionchecker:1.1.0'
  implementation 'com.electronwill.night-config:toml:3.6.6'

  implementation 'net.lingala.zip4j:zip4j:2.11.2'
  implementation 'org.xerial:sqlite-jdbc:3.39.3.0'
  implementation 'org.pf4j:pf4j:3.7.0'
  implementation 'com.github.vatbub:mslinks:1.0.5'

  annotationProcessor 'org.jetbrains:annotations:23.0.0'

  implementation 'org.apache.logging.log4j:log4j-core:2.19.0'
  implementation 'org.apache.logging.log4j:log4j-api:2.19.0'
  implementation 'org.apache.logging.log4j:log4j-slf4j-impl:2.19.0'
  implementation 'org.apache.logging.log4j:log4j-web:2.19.0'
  implementation 'org.jgroups:jgroups:5.2.6.Final'

  // GUI
  implementation 'io.github.vincenzopalazzo:material-ui-swing:1.1.4'
  implementation 'de.griefed:larsonscanner:1.0.4'

  // WEB
  implementation 'org.springframework.boot:spring-boot-starter-web:2.7.4'
  implementation 'org.springframework.boot:spring-boot-starter-log4j2:2.7.4'
  implementation 'org.apache.activemq:artemis-jms-server:2.19.1'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa:2.7.4'
  implementation 'org.springframework.boot:spring-boot-starter-artemis:2.7.4'
  implementation 'com.github.gwenn:sqlite-dialect:0.1.2'

  // Dev tools
  developmentOnly 'org.springframework.boot:spring-boot-devtools:2.7.4'

  // Testing
  testImplementation 'org.junit.jupiter:junit-jupiter:5.9.0'
  testImplementation 'org.junit.platform:junit-platform-suite:1.9.0'
  testImplementation 'org.springframework.boot:spring-boot-starter-test:2.7.4'
}

licenseReport {
  // Set output directory for the report data.
  // Defaults to ${project.buildDir}/reports/dependency-license.
  outputDir = "$projectDir/licenses"

  // Select projects to examine for dependencies.
  // Defaults to current project and all its subprojects
  projects = [project] + project.subprojects

  // Adjust the configurations to fetch dependencies. Default is 'runtimeClasspath'
  // For Android projects use 'releaseRuntimeClasspath' or 'yourFlavorNameReleaseRuntimeClasspath'
  // Use 'ALL' to dynamically resolve all configurations:
  // configurations = ALL
  configurations = ['runtimeClasspath']

  // Don't include artifacts of project's own group into the report
  excludeOwnGroup = false

  // Don't exclude bom dependencies.
  // If set to true, then all boms will be excluded from the report
  excludeBoms = true

  filters = [new ExcludeTransitiveDependenciesFilter(), new LicenseBundleNormalizer()]

  // Set custom report renderer, implementing ReportRenderer.
  // Yes, you can write your own to support any format necessary.
  renderers = [new InventoryHtmlReportRenderer('index.html', 'Dependency Licences'), new InventoryMarkdownReportRenderer("licences.md", "Licenses")]
}

// Configure frontend plugin. See documentation at https://siouan.github.io/frontend-gradle-plugin/.
frontend {
  packageJsonDirectory = file("${projectDir}/frontend")

  nodeVersion = '16.9.1'
  nodeInstallDirectory = file("${projectDir}/frontend/node")

  yarnEnabled = false
  //yarnVersion = "1.22.11"
  //yarnInstallDirectory = file("${projectDir}/frontend/yarn")

  cleanScript = 'run clean'
  assembleScript = 'run build'

  // Print the architecture we are running on.
  System.out.println(String.format("I am running on: %s", System.getProperty("os.arch")))

  // If we are running on arm, specify Node path pattern so arm-builds succeed.
  if (System.getProperty("os.arch").equals("arm")) {
    nodeDistributionUrlPathPattern = 'vVERSION/node-vVERSION-linux-armv7l.TYPE'
  } else if (System.getProperty("os.arch").equals("aarch64")) {
    nodeDistributionUrlPathPattern = 'vVERSION/node-vVERSION-linux-arm64.TYPE'
  }
}

build.finalizedBy(createExe)

// Make sure quasar is installed
tasks.register('installQuasar', RunNpm) {
  dependsOn tasks.named('installNode')
  script = 'install -g @quasar/cli'
}

// Custom task to build and copy an up-to-date version of our frontend to SpringBoot.
tasks.register('copyDist', Copy) {
  dependsOn tasks.named('installQuasar')
  dependsOn tasks.named('assembleFrontend')

  file("backend/main/resources/static").list().each {
    f ->
      delete "${"backend/main/resources/static"}/${f}"
  }
  copy {
    from layout.projectDirectory.dir("frontend/dist/spa")
    into layout.projectDirectory.dir("backend/main/resources/static")
  }

  copy {
    from layout.projectDirectory.file("LICENSE")
    into layout.projectDirectory.dir("backend/main/resources")
  }

  copy {
    from layout.projectDirectory.file("README.md")
    into layout.projectDirectory.dir("backend/main/resources")
  }

  copy {
    from layout.projectDirectory.file("HELP.md")
    into layout.projectDirectory.dir("backend/main/resources")
  }

  copy {
    from layout.projectDirectory.file("CHANGELOG.md")
    into layout.projectDirectory.dir("backend/main/resources")
  }

  copy {
    from layout.projectDirectory.file("CONTRIBUTING.md")
    into layout.projectDirectory.dir("backend/main/resources")
  }

  copy {
    from layout.projectDirectory.file("CODE_OF_CONDUCT.md")
    into layout.projectDirectory.dir("backend/main/resources")
  }

  copy {
    from layout.projectDirectory.dir("manifests")
    into layout.projectDirectory.dir("backend/main/resources/de/griefed/resources/manifests")
  }

  file("backend/main/resources/licenses").list().each {
    f ->
      delete "${"backend/main/resources/licenses"}/${f}"
  }
  copy {
    from layout.projectDirectory.dir("licenses")
    into layout.projectDirectory.dir("backend/main/resources/licenses")
  }
}

// Make sure everything is included in our JavaDoc.
// Since this project is open source, we can include private etc. classes and methods docs.
tasks.withType(Javadoc) {
  options.addStringOption('encoding', 'UTF-8')
}

// Launch4j builds our ServerPackCreator.exe.
launch4j {
  mainClassName = project.mainClass
  jarTask = project.tasks.jar
  fileDescription = project.projectDescription
  version = project.version
  textVersion = project.version
  windowTitle = project.title
  copyright = project.lic
  downloadUrl = "https://github.com/Griefed/serverpackcreator/releases"
  supportUrl = "https://github.com/Griefed/serverpackcreator/issues"
  libraryDir = 'libraries'
  outputDir = 'libs'
  icon = "${projectDir}/backend/main/resources/de/griefed/resources/gui/icon.ico"
}

clean {
  cleanFrontend
  delete('log4j2.xml')
  file("tests").list().each {
    f ->
      delete "${"tests"}/${f}"
  }
}

test.doFirst {
  mkdir("tests")
}

test {
  useJUnitPlatform()

  testLogging {
    events (
        "passed",
        "skipped",
        "failed"
    )
  }
  doLast {
    copy {
      from layout.projectDirectory.dir("tests/manifests")
      into layout.projectDirectory.dir("manifests")
    }
  }
}

javadoc {
  if (JavaVersion.current().isJava9Compatible()) {
    options.addBooleanOption('html5', true)
  }
  classpath = sourceSets.main.runtimeClasspath
}

// Build JavaDoc and JavaSources JARs.
java {
  withSourcesJar()
  withJavadocJar()
}

bootJar {
  // Customize MANIFEST to include relevant information.
  manifest {
    attributes(
        "Start-Class": project.mainClass,
        "Description": project.projectDescription,
        "Built-By": System.getProperty("user.name"),
        "Build-Timestamp": new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").format(new Date()),
        "Created-By": "Gradle ${gradle.gradleVersion}",
        "Build-Jdk": "${System.getProperty('java.version')} (${System.getProperty('java.vendor')} ${System.getProperty('java.vm.version')})",
        "Build-OS": "${System.getProperty('os.name')} ${System.getProperty('os.arch')} ${System.getProperty('os.version')}",
        "Implementation-Vendor": project.author,
        "Implementation-Version": project.version,
        "Implementation-Title": project.implTitle,
        "Application-Name": project.title
    )

  }
  exclude(
      'META-INF/org',
      'META-INF/org/**',
      'META-INF/versions',
      'META-INF/versions/**',
      'META-INF/DEPENDENCIES',
      'META-INF/LICENSE',
      'META-INF/NOTICE',
      'META-INF/CHANGES',
      'META-INF/LICENSE.txt',
      'META-INF/NOTICE.txt',
      'META-INF/README.md',
      'Log4j-**',
      'icon.png',
      'profile_icon.png'
  )
}


// JAR configuration still needed for Launch4j.
jar {
  // No duplicates
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE

  // Include all libraries in our JAR-file.
  from {
    configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
  }

  // Customize MANIFEST to include relevant information.
  manifest {
    attributes(
        "Main-Class": project.mainClass,
        "Description": project.projectDescription,
        "Built-By": System.getProperty("user.name"),
        "Build-Timestamp": new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ").format(new Date()),
        "Created-By": "Gradle ${gradle.gradleVersion}",
        "Build-Jdk": "${System.getProperty('java.version')} (${System.getProperty('java.vendor')} ${System.getProperty('java.vm.version')})",
        "Build-OS": "${System.getProperty('os.name')} ${System.getProperty('os.arch')} ${System.getProperty('os.version')}",
        "Implementation-Vendor": project.author,
        "Implementation-Version": project.version,
        "Implementation-Title": project.implTitle,
        "Application-Name": project.title
    )
  }
  // Exclude files and folders which would otherwise bloat our JAR-file up.
  exclude(
      'META-INF/org',
      'META-INF/org/**',
      'META-INF/versions',
      'META-INF/versions/**',
      'META-INF/DEPENDENCIES',
      'META-INF/LICENSE',
      'META-INF/NOTICE',
      'META-INF/CHANGES',
      'META-INF/LICENSE.txt',
      'META-INF/NOTICE.txt',
      'META-INF/README.md',
      'Log4j-**',
      'icon.png',
      'profile_icon.png'
  )
}

nexusPublishing {
  repositories {
    sonatype {
      nexusUrl = uri("https://s01.oss.sonatype.org/service/local/")
      snapshotRepositoryUrl.set(uri("https://s01.oss.sonatype.org/content/repositories/snapshots/"))
      username = System.getenv("OSSRH_USERNAME")
      password = System.getenv("OSSRH_PASSWORD")
    }
  }
}

publishing {
  publications {
    mavenJava(MavenPublication) {

      groupId = project.group
      artifactId = project.implTitle
      from components.java
      version = project.version

      pom {
        name = project.title
        description = project.projectDescription
        url = ' https://' + project.projectUrl

        licenses {
          license {
            name = project.lic
            url = project.licUrl
          }
        }

        developers {
          developer {
            id = project.authorLowerCase
            name = project.author
            email = project.authorMail
          }
        }

        scm {
          connection = 'scm:git:git:' + project.projectUrl + '.git'
          developerConnection = 'scm:git:ssh://' + project.projectUrl + '.git'
          url = 'https://' + project.projectUrl
        }

      }
    }
  }

  repositories {

    maven {
      name = "GitHubPackages"
      url = "https://maven.pkg.github.com/Griefed/serverpackcreator"
      credentials {
        username = System.getenv("GITHUB_ACTOR")
        password = System.getenv("GITHUB_TOKEN")
      }
    }

    maven {
      url = "https://git.griefed.de/api/v4/projects/63/packages/maven"
      credentials(HttpHeaderCredentials) {
        name = "Private-Token"
        value = System.getenv("GITLAB_TOKEN")
      }
      authentication {
        header(HttpHeaderAuthentication)
      }
    }

    maven {
      url = "https://gitlab.com/api/v4/projects/32677538/packages/maven"
      credentials(HttpHeaderCredentials) {
        name = "Private-Token"
        value = System.getenv("GITLABCOM_TOKEN")
      }
      authentication {
        header(HttpHeaderAuthentication)
      }
    }

  }
}

signing {
  def signingKey = findProperty("signingKey")
  def signingPassword = findProperty("signingPassword")

  useInMemoryPgpKeys(signingKey, signingPassword)
  sign publishing.publications.mavenJava
}
